var p: Promise<void>

[/*comment in array*/]

const COMPILER_PROVIDERS: Array<any[]> = null

class Foo {

  bar() {
    return this
  }
}

var b = (123) && 123
var k =  new K<Array<number>>()
var d = 33<333

class K<T> {
  private m: Map<string, Promimse<string>> = new Map<string, Promise<string>>()
	private a = new K<Array<number>>()
	private b: K<Array<number>> =
    new K<Array<number>>()
	private c: K<Array<number>> =
    <K<Array<number>>> new K()
	private d = 123
  private e: () => number = 123

  method() {
      var a = this.e!
      var a = super
      return super
  }

}

function prop<T, K extends keyof T>(t: T, k: K): T[K] {
}

interface A {
}

var a = [/\/\//, 123]

class A extends B implements C
{
	private a = 123
    b
}



if (a < (<number>b))
    a
}

var a = 123

abstract class Comp {
    context: any;
    abstract up(db: IBaseProtocol<any>): Promimse<void>;
    abstract down(db: IBaseProtocol<any>): Promimse<void>;
}

class MyClass {
    noed // ewewe
    a = '3' // ewew
}

filter((test
) => {
    const name = 33
})

process.stdout
document
    /* test */
    .createElement
function test({a = process.stdout}) {}

class A {
    test?: string
    readonly emails?: Array<string>
    readonly photos?: Array<string>
    readonly photos!: Array<string>
    method?(): string
    abstract test();

    constructor() {
    }
}

a = 'static-native'
// test
var a = 1/3
/* test*/
type A = 42
abstract class BadClass {
  abstract method1 (): Promise<number>;
  abstract method2 (): Promise<string>;
}

{
    (this as{collection: V[] | Iterable<V>}).collection = collection;
    this._addAfter(new IterableChangeRecord_<V>(item, itemTrackBy), previousRecord, index);
    return this.isDirty;
}


getSymbolIterator(3) in obj;

class B {
  abstract get parent(): Injector|null;
}
class A {
  test(): void
  test(s: string): void
  test(s?: string): void
}


export class QueryList<T>/* implements Iterable<T> */ {
}
  public readonly dirty = true;
